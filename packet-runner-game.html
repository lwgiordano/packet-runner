<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IP-Venger: The Packet Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            color: #00ffff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            background: rgba(0, 0, 0, 0.8);
        }

        #gameCanvas {
            display: block;
            background: #000011;
            transition: filter 0.3s ease; /* Keep transition for smooth blurring */
        }

        .game-blur {
            filter: blur(3px);
        }

        .no-blur-transition {
            transition: none !important;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            z-index: 10;
            font-weight: 700;
        }

        .hud-section {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border: 1px solid #00ffff;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .hud-center {
            text-align: center;
        }

        .hud-right {
            text-align: right;
        }

        #targetIP {
            font-size: 18px;
            color: #4ecdc4;
        }

        #targetPort {
            font-size: 14px;
            color: #4ecdc4;
            margin-top: 2px;
        }

        #score {
            font-size: 16px;
            color: #4ecdc4;
        }

        #level {
            font-size: 14px;
            color: #00ff00;
        }

        #combo {
            font-size: 12px;
            color: #ff6b6b;
        }

        #ttl {
            font-size: 16px;
            color: #ffe66d;
        }

        #bandwidth {
            font-size: 12px;
            color: #ff00ff;
        }

        .dash-container {
            margin-top: 4px;
        }

        .dash-label {
            font-size: 12px;
            color: #00ffff;
            margin-bottom: 2px;
        }

        #dashCooldown {
            width: 60px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        #dashBar {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ffffff);
            border-radius: 3px;
            transition: width 0.1s;
        }

        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 11px;
            color: #888;
            z-index: 10;
        }

        #networkTip {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            text-align: center;
            z-index: 25;
            display: none;
        }

        #networkTip h3 {
            color: #00ffff;
            margin: 0 0 10px 0;
        }

        #networkTip p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
        }

        #networkTip button {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: white;
            border: none;
            padding: 8px 16px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        #startMenu, #instructionsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            z-index: 30;
        }

        #startMenu {
            max-width: 500px;
        }

        #instructionsMenu {
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            max-height: 600px;
            overflow-y: auto;
        }

        #startMenu h1 {
            margin: 0 0 10px 0;
            font-size: 58px;
            font-weight: 900;
            background: linear-gradient(45deg, #ff0080, #00ffff, #ff8000, #ff0080, #00ffff);
            background-size: 400% 400%;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: retroGlow 2s ease-in-out infinite;
            text-shadow: 
                0 0 5px #ff0080,
                0 0 10px #ff0080,
                0 0 15px #00ffff,
                0 0 20px #00ffff,
                0 0 25px #ff0080,
                0 0 30px #ff8000,
                0 0 35px #ff0080;
            filter: 
                drop-shadow(0 0 10px #ff0080) 
                drop-shadow(0 0 20px #00ffff)
                drop-shadow(0 0 30px #ff8000);
            letter-spacing: 3px;
            transform: perspective(500px) rotateX(15deg);
        }

        @keyframes retroGlow {
            0% { 
                background-position: 0% 50%;
                filter: 
                    drop-shadow(0 0 15px #ff0080) 
                    drop-shadow(0 0 25px #00ffff)
                    drop-shadow(0 0 35px #ff8000)
                    brightness(1.2)
                    saturate(1.5);
            }
            25% {
                background-position: 25% 50%;
                filter: 
                    drop-shadow(0 0 20px #00ffff) 
                    drop-shadow(0 0 30px #ff8000)
                    drop-shadow(0 0 40px #ff0080)
                    brightness(1.4)
                    saturate(1.8);
            }
            50% { 
                background-position: 50% 50%;
                filter: 
                    drop-shadow(0 0 25px #ff8000) 
                    drop-shadow(0 0 35px #ff0080)
                    drop-shadow(0 0 45px #00ffff)
                    brightness(1.6)
                    saturate(2.0);
            }
            75% {
                background-position: 75% 50%;
                filter: 
                    drop-shadow(0 0 20px #ff0080) 
                    drop-shadow(0 0 30px #00ffff)
                    drop-shadow(0 0 40px #ff8000)
                    brightness(1.4)
                    saturate(1.8);
            }
            100% { 
                background-position: 100% 50%;
                filter: 
                    drop-shadow(0 0 15px #ff0080) 
                    drop-shadow(0 0 25px #00ffff)
                    drop-shadow(0 0 35px #ff8000)
                    brightness(1.2)
                    saturate(1.5);
            }
        }

        #startMenu .subtitle {
            color: #4ecdc4;
            margin: 0 0 30px 0;
            font-size: 16px;
            font-weight: 400;
        }

        #instructionsMenu h2 {
            color: #00ffff;
            margin: 0 0 20px 0;
            font-size: 28px;
            font-weight: 900;
        }

        .menu-button {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: white;
            border: 2px solid transparent;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            min-width: 200px;
            outline: none;
        }

        .menu-button:hover, .menu-button:focus, .menu-button.focused {
            background: linear-gradient(45deg, #0088ff, #00aaff);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            transform: translateY(-2px);
            border: 2px solid #00ffff;
        }

        .instructions-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            text-align: left;
            margin: 20px 0;
            line-height: 1.6;
            font-size: 14px;
        }

        .instructions-column h3 {
            color: #4ecdc4;
            margin: 15px 0 8px 0;
            font-size: 16px;
        }

        .instructions-column ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .instructions-column li {
            margin: 4px 0;
            color: #cccccc;
        }

        .key-highlight {
            color: #ffe66d;
            font-weight: bold;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            z-index: 20;
            display: none;
        }

        #gameOver h2 {
            color: #ff6b6b;
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        #gameOverReason {
            color: #ffaa00;
            font-size: 16px;
            margin: 10px 0;
            font-weight: bold;
        }

        #gameOver button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #gameOver button:hover, #gameOver button:focus {
            background: linear-gradient(45deg, #ff8e8e, #ffaaaa);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        #networkTip button:hover, #networkTip button:focus {
            background: linear-gradient(45deg, #0088ff, #00aaff);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .celebration {
            position: absolute;
            font-size: 20px;
            font-weight: 900;
            color: #00ff00;
            pointer-events: none;
            z-index: 15;
            animation: celebrate 1.2s ease-out forwards;
        }

        @keyframes celebrate {
            0% { transform: scale(0.5) translateY(0); opacity: 1; }
            50% { transform: scale(1.2) translateY(-20px); opacity: 1; }
            100% { transform: scale(1) translateY(-40px); opacity: 0; }
        }

        .subnet-legend {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 4px;
            padding: 8px;
            font-size: 10px;
            z-index: 10;
        }

        .subnet-item {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }

        .subnet-color {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="startMenu">
            <h1>PACKET RUNNER</h1>
            <div class="subtitle">Navigate the Digital Highway</div>
            <button class="menu-button focused" id="startButton" onclick="game.startGame()">START GAME</button>
            <button class="menu-button" id="instructionsButton" onclick="game.showInstructions()">INSTRUCTIONS</button>
        </div>

        <div id="instructionsMenu" style="display: none;">
            <h2>HOW TO PLAY PACKET RUNNER</h2>
            <div class="instructions-content">
                <div class="instructions-column">
                    <h3>🎯 Mission</h3>
                    <p>You are a data packet navigating the internet! Deliver yourself to the correct IP address before your TTL (Time-To-Live) expires.</p>
                    
                    <h3>🎮 Controls</h3>
                    <ul>
                        <li><span class="key-highlight">Arrow Keys / WASD</span> - Move your packet</li>
                        <li><span class="key-highlight">SPACE</span> - Dash (limited cooldown)</li>
                        <li><span class="key-highlight">ENTER</span> - Pause and show/hide instructions</li>
                    </ul>
                    
                    <h3>🔧 Game Elements</h3>
                    <ul>
                        <li><span class="key-highlight">Servers</span> - Read IP addresses carefully to find your target</li>
                        <li><span class="key-highlight">Ports</span> - Later levels require matching both IP AND port number</li>
                        <li><span class="key-highlight">Firewalls</span> - Red diamonds that block packets - avoid them!</li>
                        <li><span class="key-highlight">Safe Zones</span> - Green corners repel firewalls</li>
                    </ul>
                </div>
                <div class="instructions-column">
                    <h3>🔋 Network Resources</h3>
                    <ul>
                        <li><span class="key-highlight">Packet Boosts (P)</span> - Restore TTL time</li>
                        <li><span class="key-highlight">Bandwidth Boosts (B)</span> - Temporary speed increase</li>
                        <li><span class="key-highlight">Cache Boosts (C)</span> - Major TTL restoration</li>
                        <li><span class="key-highlight">Ping Boosts (!)</span> - Small TTL boost</li>
                    </ul>
                    
                    <h3>🌐 Advanced Features</h3>
                    <ul>
                        <li><span class="key-highlight">Routers</span> - Green triangles teleport you across the network</li>
                        <li><span class="key-highlight">Subnets</span> - Color-coded network zones for organization</li>
                        <li><span class="key-highlight">Combo System</span> - Build streaks for massive score bonuses</li>
                    </ul>
                    
                    <h3>📚 Learn Real Networking</h3>
                    <p>As you progress, you'll learn about IP subnets, port numbers, and real network routing concepts used in modern internet infrastructure!</p>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="menu-button" id="backButton" onclick="game.showStartMenu()">BACK TO MENU</button>
            </div>
        </div>

        <div id="hud" style="display: none;">
            <div class="hud-section">
                <div>TARGET: <span id="targetIP">192.168.1.10</span></div>
                <div id="targetPort"></div>
            </div>
            <div class="hud-section hud-center">
                <div id="level">LEVEL: 1</div>
                <div id="score">SCORE: 0</div>
                <div id="combo"></div>
            </div>
            <div class="hud-section hud-right">
                <div id="ttl">TTL: 120</div>
                <div id="bandwidth">BANDWIDTH: 100%</div>
                <div class="dash-container">
                    <div class="dash-label">DASH:</div>
                    <div id="dashCooldown"><div id="dashBar"></div></div>
                </div>
            </div>
        </div>

        <div class="subnet-legend" id="subnetLegend" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 4px;">SUBNETS:</div>
        </div>

        <div id="instructions">
            ARROW KEYS: Move | SPACE: Dash | ENTER: Pause / Instructions<br>
            Read IP addresses carefully to find your target!
        </div>

        <div id="networkTip">
            <h3 id="tipTitle">Network Tip</h3>
            <p id="tipContent">Loading...</p>
            <button id="tipButton" onclick="game.closeNetworkTip()">GOT IT!</button>
        </div>

        <div id="gameOver">
            <h2>PACKET DROPPED!</h2>
            <div id="gameOverReason">Connection timeout occurred</div>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Best Combo: <span id="bestCombo">0</span></p>
            <p>Highest Level: <span id="highestLevel">1</span></p>
            <button id="restartButton" onclick="game.restart()">BACK TO MENU</button>
        </div>
    </div>

    <script>
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }

            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }

            distance(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            normalize() {
                const length = Math.sqrt(this.x * this.x + this.y * this.y);
                if (length === 0) return new Vector2(0, 0);
                return new Vector2(this.x / length, this.y / length);
            }
        }

        class Particle {
            constructor(x, y, color, life = 60) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                );
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.position = this.position.add(this.velocity);
                this.velocity = this.velocity.multiply(0.98);
                this.life--;
            }

            render(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class NetworkResource {
            constructor(x, y, type) {
                this.position = new Vector2(x, y);
                this.type = type; // 'packet', 'bandwidth', 'cache', 'ping'
                this.bobPhase = Math.random() * Math.PI * 2;
                this.rotationSpeed = 0.05;
                this.rotation = 0;
                this.size = 8;
                this.collected = false;
                this.value = this.getTypeValue();
                this.color = this.getTypeColor();
                this.name = this.getTypeName();
            }

            getTypeValue() {
                switch(this.type) {
                    case 'packet': return 18; // Good TTL boost
                    case 'bandwidth': return 10; // Speed boost
                    case 'cache': return 30; // Great TTL boost
                    case 'ping': return 7; // Small TTL boost
                    default: return 10;
                }
            }

            getTypeColor() {
                switch(this.type) {
                    case 'packet': return '#00ff00';
                    case 'bandwidth': return '#ff00ff';
                    case 'cache': return '#ffaa00';
                    case 'ping': return '#00ffff';
                    default: return '#ffffff';
                }
            }

            getTypeName() {
                switch(this.type) {
                    case 'packet': return 'PACKET BOOST';
                    case 'bandwidth': return 'BANDWIDTH BOOST';
                    case 'cache': return 'CACHE BOOST';
                    case 'ping': return 'PING BOOST';
                    default: return 'NETWORK BOOST';
                }
            }

            getTypeSymbol() {
                switch(this.type) {
                    case 'packet': return 'P';
                    case 'bandwidth': return 'B';
                    case 'cache': return 'C';
                    case 'ping': return '!';
                    default: return '?';
                }
            }

            update() {
                this.bobPhase += 0.1;
                this.rotation += this.rotationSpeed;
            }

            render(ctx) {
                const bobOffset = Math.sin(this.bobPhase) * 4;
                
                ctx.save();
                ctx.translate(this.position.x, this.position.y + bobOffset);
                ctx.rotate(this.rotation);

                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                
                // Draw as hexagon
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = Math.cos(angle) * this.size;
                    const y = Math.sin(angle) * this.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();

                // Fill
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.3;
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();

                // Symbol
                ctx.shadowBlur = 0;
                ctx.fillStyle = this.color;
                ctx.font = 'bold 10px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(this.getTypeSymbol(), this.position.x, this.position.y + bobOffset + 3);
            }

            checkCollision(player) {
                return this.position.distance(player.position) < this.size + player.size && !this.collected;
            }
        }

        class Router {
            constructor(x, y, linkedRouter = null) {
                this.position = new Vector2(x, y);
                this.linkedRouter = linkedRouter;
                this.size = 15;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.cooldown = 0;
            }

            update() {
                this.pulsePhase += 0.15;
                if (this.cooldown > 0) this.cooldown--;
            }

            render(ctx) {
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                const color = this.cooldown > 0 ? '#666666' : '#00aa00';

                ctx.shadowColor = color;
                ctx.shadowBlur = 15 * pulse;
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;

                // Draw router as triangle
                ctx.beginPath();
                ctx.moveTo(this.position.x, this.position.y - this.size);
                ctx.lineTo(this.position.x - this.size, this.position.y + this.size/2);
                ctx.lineTo(this.position.x + this.size, this.position.y + this.size/2);
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.globalAlpha = pulse * 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Connection indicator
                if (this.linkedRouter && this.cooldown === 0) {
                    ctx.strokeStyle = 'rgba(0, 170, 0, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y);
                    ctx.lineTo(this.linkedRouter.position.x, this.linkedRouter.position.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.shadowBlur = 0;
                ctx.fillStyle = color;
                ctx.font = '8px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('RTR', this.position.x, this.position.y + 25);
            }

            checkCollision(player) {
                return this.position.distance(player.position) < this.size + player.size && this.cooldown === 0;
            }

            activate() {
                this.cooldown = 180; // 3 second cooldown
            }
        }

        class ServerNode {
            constructor(x, y, ip, subnet = null) {
                this.position = new Vector2(x, y);
                this.ip = ip;
                this.subnet = subnet;
                this.size = 16;
                this.isTarget = false;
                this.targetPort = null;
                this.availablePorts = []; // Ports this server offers
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.safeZone = false;
                this.services = ['web:80', 'mail:25', 'ssh:22', 'ftp:21', 'dns:53'];
            }

            update() {
                this.pulsePhase += 0.1;
            }

            getSubnetColor() {
                if (!this.subnet) return '#4ecdc4';
                const colors = {
                    '192.168.1': '#ff6b6b',
                    '192.168.0': '#4ecdc4', 
                    '10.0.0': '#ffe66d',
                    '172.16.1': '#ff8c42'
                };
                return colors[this.subnet] || '#4ecdc4';
            }

            render(ctx) {
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                const baseColor = this.getSubnetColor();
                const color = baseColor;
                const glowIntensity = this.isTarget ? 18 : 12;

                // Subnet zone background
                if (this.subnet) {
                    ctx.shadowColor = baseColor;
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = baseColor;
                    ctx.globalAlpha = 0.05;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, 35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Safe zone aura
                if (this.safeZone) {
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.08)';
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, 35, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Glow effect
                ctx.shadowColor = color;
                ctx.shadowBlur = glowIntensity * pulse;

                // Outer ring
                ctx.strokeStyle = color;
                ctx.lineWidth = this.isTarget ? 3 : 2;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.stroke();

                // Inner core
                ctx.fillStyle = color;
                ctx.globalAlpha = pulse * (this.isTarget ? 0.4 : 0.3);
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size - 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Show available ports on ALL servers
                if (this.availablePorts.length > 0) {
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = color;
                    ctx.font = '13px Orbitron';
                    ctx.textAlign = 'center';
                    
                    const portsText = this.availablePorts.join(',');
                    ctx.fillText(`:${portsText}`, this.position.x, this.position.y - 25);
                }

                // IP Address label
                ctx.shadowBlur = 0;
                ctx.fillStyle = color;
                ctx.font = '14px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(this.ip, this.position.x, this.position.y + 35);
            }

            checkCollision(player) {
                return this.position.distance(player.position) < this.size + player.size - 3;
            }

            isInSafeZone(pos) {
                return this.safeZone && this.position.distance(pos) < 35;
            }

            hasPort(port) {
                return this.availablePorts.includes(port);
            }

            checkPortCollision(player, targetPort) {
                if (!this.checkCollision(player)) return false;
                if (!targetPort) return true;
                return this.hasPort(targetPort);
            }
        }

        class Firewall {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                const speedMultiplier = Math.min(1.1 + (this.level || 0) * 0.1, 1.9);
                this.velocity = new Vector2(
                    (Math.random() - 0.5) * 1.1 * speedMultiplier,
                    (Math.random() - 0.5) * 1.1 * speedMultiplier
                );
                this.size = 12;
                this.rotationSpeed = 0.08;
                this.rotation = 0;
                this.stunned = 0;
                this.pattern = Math.floor(Math.random() * 3);
            }

            update(safeZones = [], level = 1) {
                if (this.stunned > 0) {
                    this.stunned--;
                    return;
                }

                if (level >= 4) {
                    if (Math.random() < 0.02 * Math.min(level / 4, 2.5)) {
                        this.velocity = this.velocity.multiply(-1);
                    }
                }

                for (let zone of safeZones) {
                    if (zone.isInSafeZone(this.position)) {
                        this.velocity = this.velocity.multiply(-1.5);
                        this.stunned = 30;
                        break;
                    }
                }

                this.position = this.position.add(this.velocity);
                this.rotation += this.rotationSpeed;

                if (this.position.x <= this.size + 20 || this.position.x >= 800 - this.size - 20) {
                    this.velocity.x *= -1;
                }
                if (this.position.y <= this.size + 20 || this.position.y >= 600 - this.size - 20) {
                    this.velocity.y *= -1;
                }

                this.position.x = Math.max(this.size + 20, Math.min(800 - this.size - 20, this.position.x));
                this.position.y = Math.max(this.size + 20, Math.min(600 - this.size - 20, this.position.y));
            }

            render(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.rotation);

                const color = this.stunned > 0 ? '#ff9999' : '#ff3333';

                ctx.shadowColor = color;
                ctx.shadowBlur = 12;

                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, 0);
                ctx.lineTo(0, this.size);
                ctx.lineTo(-this.size, 0);
                ctx.closePath();
                ctx.stroke();

                ctx.strokeStyle = this.stunned > 0 ? '#ffcccc' : '#ff6666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -this.size + 3);
                ctx.lineTo(this.size - 3, 0);
                ctx.lineTo(0, this.size - 3);
                ctx.lineTo(-this.size + 3, 0);
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
            }

            checkCollision(player) {
                return this.position.distance(player.position) < this.size + player.size - 2 && player.invulnerable === 0;
            }
        }

        class Player {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2(0, 0);
                this.size = 8;
                this.baseSpeed = 2.3;
                this.speed = this.baseSpeed;
                this.dashSpeed = 7;
                this.dashCooldown = 0;
                this.dashDuration = 0;
                this.maxDashCooldown = 50;
                this.trail = [];
                this.maxTrailLength = 20;
                this.invulnerable = 0;
                this.bandwidthBoost = 0;
                
                this.spawnAnimation = 90;
                this.spawnParticles = [];
            }

            update(input) {
                if (this.spawnAnimation > 0) {
                    this.spawnAnimation--;
                    
                    if (this.spawnAnimation % 2 === 0) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 50 + Math.random() * 40;
                        const startX = this.position.x + Math.cos(angle) * distance;
                        const startY = this.position.y + Math.sin(angle) * distance;
                        
                        this.spawnParticles.push({
                            position: new Vector2(startX, startY),
                            targetPosition: new Vector2(this.position.x, this.position.y),
                            life: 40,
                            maxLife: 40,
                            size: 1 + Math.random() * 3
                        });
                    }
                    
                    this.spawnParticles = this.spawnParticles.filter(particle => {
                        particle.life--;
                        const progress = 1 - (particle.life / particle.maxLife);
                        particle.position.x = particle.position.x + (particle.targetPosition.x - particle.position.x) * 0.08;
                        particle.position.y = particle.position.y + (particle.targetPosition.y - particle.position.y) * 0.08;
                        return particle.life > 0;
                    });
                    
                    return;
                }

                if (this.dashCooldown > 0) this.dashCooldown--;
                if (this.dashDuration > 0) this.dashDuration--;
                if (this.invulnerable > 0) this.invulnerable--;
                if (this.bandwidthBoost > 0) {
                    this.bandwidthBoost--;
                    this.speed = this.baseSpeed * 1.5;
                } else {
                    this.speed = this.baseSpeed;
                }

                this.velocity = new Vector2(0, 0);
                const currentSpeed = this.dashDuration > 0 ? this.dashSpeed : this.speed;

                if (input.left) this.velocity.x = -currentSpeed;
                if (input.right) this.velocity.x = currentSpeed;
                if (input.up) this.velocity.y = -currentSpeed;
                if (input.down) this.velocity.y = currentSpeed;

                if (this.velocity.x !== 0 && this.velocity.y !== 0) {
                    this.velocity = this.velocity.normalize().multiply(currentSpeed);
                }

                if (input.dash && this.dashCooldown === 0) {
                    this.dashDuration = 15;
                    this.dashCooldown = this.maxDashCooldown;
                    this.invulnerable = 15;
                }

                this.position = this.position.add(this.velocity);

                const padding = 30;
                this.position.x = Math.max(padding, Math.min(800 - padding, this.position.x));
                this.position.y = Math.max(padding, Math.min(600 - padding, this.position.y));

                if (this.velocity.x !== 0 || this.velocity.y !== 0) {
                    this.trail.push({...this.position});
                }
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
            }

            render(ctx) {
                if (this.spawnAnimation > 0) {
                    this.spawnParticles.forEach(particle => {
                        const alpha = particle.life / particle.maxLife;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#00ffff';
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(particle.position.x, particle.position.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    });
                }

                if (this.spawnAnimation > 45) {
                    return;
                }

                const trailColor = this.bandwidthBoost > 0 ? '#ff00ff' : (this.invulnerable > 0 ? '#ffffff' : '#00ffff');
                ctx.strokeStyle = trailColor;
                ctx.lineWidth = this.bandwidthBoost > 0 ? 3 : 2;
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const alpha = (i / this.trail.length) * 0.8;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                let glowColor = '#00ffff';
                let size = this.size;
                
                if (this.spawnAnimation > 0) {
                    const spawnProgress = 1 - (this.spawnAnimation / 45);
                    size = this.size * spawnProgress * 1.5;
                    glowColor = '#ffffff';
                    ctx.globalAlpha = Math.min(1, spawnProgress + 0.3);
                } else if (this.invulnerable > 0) {
                    glowColor = '#ffffff';
                    size = this.size + 3;
                } else if (this.dashDuration > 0) {
                    glowColor = '#ffffff';
                    size = this.size + 2;
                } else if (this.bandwidthBoost > 0) {
                    glowColor = '#ff00ff';
                    size = this.size + 1;
                }

                if (this.invulnerable > 0 && this.invulnerable % 6 < 3) {
                    ctx.globalAlpha = 0.7;
                }

                ctx.shadowColor = glowColor;
                ctx.shadowBlur = this.spawnAnimation > 0 ? 25 : 15;
                
                ctx.fillStyle = glowColor;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000011';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, Math.max(0, size - 3), 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }

            getDashCooldownPercent() {
                return Math.max(0, 1 - (this.dashCooldown / this.maxDashCooldown));
            }

            getBandwidthPercent() {
                return this.bandwidthBoost > 0 ? 150 : 100;
            }

            triggerSpawn() {
                this.spawnAnimation = 90;
                this.spawnParticles = [];
                this.trail = [];
            }

            isSpawning() {
                return this.spawnAnimation > 0;
            }
        }

        class IPVengerGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.input = {
                    left: false,
                    right: false,
                    up: false,
                    down: false,
                    dash: false
                };

                this.gameState = 'MENU';
                this.selectedMenuButton = 0;
                this.pausedState = 'PLAYING';
                this.score = 0;
                this.ttl = 140;
                this.level = 1;
                this.highestLevel = 1;
                this.gameRunning = false;
                this.combo = 0;
                this.bestCombo = 0;
                this.screenShake = 0;
                this.networkTipShown = false;
                this.gameOverReason = '';

                this.player = new Player(400, 400);
                this.servers = [];
                this.firewalls = [];
                this.networkResources = [];
                this.routers = [];
                this.particles = [];
                this.targetIP = '';
                this.targetPort = null;
                this.subnets = ['192.168.1', '192.168.0', '10.0.0', '172.16.1'];

                this.networkTips = [
                    {
                        title: "Subnets Unlocked!",
                        content: "IP addresses are organized into subnets (color-coded zones). Addresses starting with the same numbers are in the same subnet - like neighborhoods in a city!"
                    },
                    {
                        title: "Ports Introduced!",
                        content: "Servers run multiple services on different ports. Port 80 = Web, 22 = SSH, 25 = Email. One server, many services!"
                    },
                    {
                        title: "Routers Available!",
                        content: "Routers (green triangles) find the fastest path for your data. Step on one to teleport to its linked router - just like real packet routing!"
                    },
                    {
                        title: "Advanced Networking!",
                        content: "You're now dealing with complex network topologies! Firewalls have learned your patterns. Use all your networking knowledge!"
                    }
                ];

                this.setupInput();
                this.gameLoop();
                
                this.updateMenuSelection();
            }

            updateMenuSelection() {
                const buttons = ['startButton', 'instructionsButton'];
                buttons.forEach((buttonId, index) => {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        if (index === this.selectedMenuButton) {
                            button.classList.add('focused');
                            button.focus();
                        } else {
                            button.classList.remove('focused');
                        }
                    }
                });
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameState === 'MENU') {
                        switch(e.code) {
                            case 'ArrowUp':
                            case 'ArrowDown':
                                this.selectedMenuButton = 1 - this.selectedMenuButton;
                                this.updateMenuSelection();
                                e.preventDefault();
                                break;
                            case 'Enter':
                                if (this.selectedMenuButton === 0) {
                                    this.startGame();
                                } else {
                                    this.showInstructions();
                                }
                                e.preventDefault();
                                break;
                        }
                        return;
                    }

                    if (this.gameState === 'INSTRUCTIONS') {
                        switch(e.code) {
                            case 'Enter':
                                if (this.pausedState === 'PLAYING') {
                                    this.closeInstructionsToGame();
                                } else {
                                    this.showStartMenu();
                                }
                                e.preventDefault();
                                break;
                        }
                        return;
                    }

                    if (this.gameState === 'PLAYING') {
                        switch(e.code) {
                            case 'Enter':
                                if (document.getElementById('gameOver').style.display === 'block') {
                                    this.restart();
                                } else if (document.getElementById('networkTip').style.display === 'block') {
                                    this.closeNetworkTip();
                                } else {
                                    this.showInstructionsFromGame();
                                }
                                e.preventDefault();
                                return;
                        }

                        switch(e.code) {
                            case 'ArrowLeft':
                            case 'KeyA':
                                this.input.left = true;
                                break;
                            case 'ArrowRight':
                            case 'KeyD':
                                this.input.right = true;
                                break;
                            case 'ArrowUp':
                            case 'KeyW':
                                this.input.up = true;
                                break;
                            case 'ArrowDown':
                            case 'KeyS':
                                this.input.down = true;
                                break;
                            case 'Space':
                                this.input.dash = true;
                                e.preventDefault();
                                break;
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (this.gameState !== 'PLAYING') return;

                    switch(e.code) {
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.input.left = false;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.input.right = false;
                            break;
                        case 'ArrowUp':
                        case 'KeyW':
                            this.input.up = false;
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            this.input.down = false;
                            break;
                        case 'Space':
                            this.input.dash = false;
                            break;
                    }
                });
            }

            // --- BLUR LOGIC FIX ---
            // This function now correctly determines when to apply blur.
            updateBlurEffect() {
                const canvas = document.getElementById('gameCanvas');
                
                // NEVER blur if we are in the MENU state. The game isn't running.
                if (this.gameState === 'MENU') {
                    canvas.classList.remove('game-blur');
                    return;
                }

                // Blur only when an overlay is visible ON TOP of the game.
                const isOverlayVisible = 
                    document.getElementById('instructionsMenu').style.display === 'block' ||
                    document.getElementById('gameOver').style.display === 'block' ||
                    document.getElementById('networkTip').style.display === 'block';

                if (isOverlayVisible) {
                    canvas.classList.add('game-blur');
                } else {
                    canvas.classList.remove('game-blur');
                }
            }

            showInstructionsFromGame() {
                this.pausedState = 'PLAYING';
                this.gameState = 'INSTRUCTIONS';
                this.gameRunning = false;
                document.getElementById('instructionsMenu').style.display = 'block';
                document.getElementById('backButton').focus();
                this.updateBlurEffect();
            }

            closeInstructionsToGame() {
                this.gameState = 'PLAYING';
                this.gameRunning = true;
                document.getElementById('instructionsMenu').style.display = 'none';
                this.updateBlurEffect();
            }

            startGame() {
                this.gameState = 'PLAYING';
                this.gameRunning = true;
                
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('instructionsMenu').style.display = 'none';
                document.getElementById('hud').style.display = 'grid';
                
                this.score = 0;
                this.ttl = 140;
                this.level = 1;
                this.combo = 0;
                this.bestCombo = 0;
                this.highestLevel = 1;
                this.screenShake = 0;
                this.particles = [];
                this.networkTipShown = false;
                this.gameOverReason = '';
                
                this.generateLevel();
                this.player.triggerSpawn();
                this.updateBlurEffect();
            }

            showInstructions() {
                this.pausedState = 'MENU';
                this.gameState = 'INSTRUCTIONS';
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('instructionsMenu').style.display = 'block';
                document.getElementById('backButton').focus();
                this.updateBlurEffect();
            }

            // --- MENU AND RESTART FIX ---
            // This function is the single, reliable way to get to the main menu.
            showStartMenu() {
                this.gameState = 'MENU';
                this.gameRunning = false;
                this.selectedMenuButton = 0;

                // Hide ALL overlays and game UI elements
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('instructionsMenu').style.display = 'none';
                document.getElementById('networkTip').style.display = 'none';
                document.getElementById('hud').style.display = 'none';

                // Show the start menu
                document.getElementById('startMenu').style.display = 'block';

                // Force remove blur immediately, bypassing any CSS transitions
                const canvas = document.getElementById('gameCanvas');
                canvas.classList.add('no-blur-transition');
                canvas.classList.remove('game-blur');
                
                // Update menu selection to focus the 'Start Game' button
                this.updateMenuSelection();
                
                // After a short delay, remove the class that bypasses transitions.
                // This re-enables smooth blurring for other situations (like pausing).
                setTimeout(() => {
                    canvas.classList.remove('no-blur-transition');
                }, 50);

                // Call the corrected blur effect logic to ensure final state is un-blurred.
                this.updateBlurEffect();
            }

            generateIP(subnet = null) {
                if (!subnet) {
                    subnet = this.subnets[Math.floor(Math.random() * this.subnets.length)];
                }
                const lastOctet = Math.floor(Math.random() * 254) + 1;
                return `${subnet}.${lastOctet}`;
            }

            findSafeSpawnPosition() {
                let attempts = 0;
                const maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    const x = Math.random() * (800 - 120) + 60;
                    const y = Math.random() * (400 - 120) + 220;
                    
                    const testPosition = new Vector2(x, y);
                    let isValid = true;
                    
                    for (let server of this.servers) {
                        if (server.position.distance(testPosition) < 80) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) { attempts++; continue; }
                    
                    for (let firewall of this.firewalls) {
                        if (firewall.position.distance(testPosition) < 100) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) { attempts++; continue; }
                    
                    for (let router of this.routers) {
                        if (router.position.distance(testPosition) < 80) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) { attempts++; continue; }
                    
                    for (let resource of this.networkResources) {
                        if (resource.position.distance(testPosition) < 60) {
                            isValid = false;
                            break;
                        }
                    }
                    
                    if (isValid) {
                        return testPosition;
                    }
                    
                    attempts++;
                }
                
                return new Vector2(400, 450);
            }

            showNetworkTip(tipIndex) {
                if (tipIndex < this.networkTips.length) {
                    const tip = this.networkTips[tipIndex];
                    document.getElementById('tipTitle').textContent = tip.title;
                    document.getElementById('tipContent').textContent = tip.content;
                    document.getElementById('networkTip').style.display = 'block';
                    document.getElementById('tipButton').focus();
                    this.gameRunning = false;
                    this.updateBlurEffect();
                }
            }

            closeNetworkTip() {
                document.getElementById('networkTip').style.display = 'none';
                this.gameRunning = true;
                this.networkTipShown = true;
                this.updateBlurEffect();
            }

            updateSubnetLegend() {
                const legend = document.getElementById('subnetLegend');
                if (this.level >= 3) {
                    legend.style.display = 'block';
                    const items = legend.querySelectorAll('.subnet-item');
                    items.forEach(item => item.remove());
                    
                    this.subnets.forEach(subnet => {
                        const item = document.createElement('div');
                        item.className = 'subnet-item';
                        
                        const colorBox = document.createElement('div');
                        colorBox.className = 'subnet-color';
                        const colors = {
                            '192.168.1': '#ff6b6b',
                            '192.168.0': '#4ecdc4', 
                            '10.0.0': '#ffe66d',
                            '172.16.1': '#ff8c42'
                        };
                        colorBox.style.backgroundColor = colors[subnet];
                        
                        const label = document.createElement('span');
                        label.textContent = subnet + '.x';
                        
                        item.appendChild(colorBox);
                        item.appendChild(label);
                        legend.appendChild(item);
                    });
                } else {
                    legend.style.display = 'none';
                }
            }

            addParticles(x, y, color, count = 10) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            addScreenShake(intensity = 5) {
                this.screenShake = Math.max(this.screenShake, intensity);
            }

            showCelebration(text, x, y) {
                const celebration = document.createElement('div');
                celebration.className = 'celebration';
                celebration.textContent = text;
                celebration.style.left = x + 'px';
                celebration.style.top = y + 'px';
                document.getElementById('gameContainer').appendChild(celebration);
                
                setTimeout(() => {
                    celebration.remove();
                }, 1200);
            }

            getGameOverReason(reason) {
                const reasons = {
                    'firewall': 'Blocked by firewall! Network security prevented packet delivery.',
                    'ttl': 'Packet expired! TTL (Time-To-Live) reached zero - routing took too long.',
                    'wrong_server': 'Address not found! Packet sent to incorrect IP address.',
                    'wrong_port': 'Service unavailable! Correct IP but wrong port - service not running.',
                    'timeout': 'Connection timeout! Network congestion caused packet loss.'
                };
                return reasons[reason] || 'Network error occurred during packet transmission.';
            }

            generateLevel() {
                this.servers = [];
                this.firewalls = [];
                this.networkResources = [];
                this.routers = [];

                const isEarlyLevel = this.level <= 4;
                const serverCount = isEarlyLevel ? 6 : Math.min(6 + Math.floor(this.level / 2), 12);

                const patterns = [
                    (index, total) => {
                        const angle = (index / total) * Math.PI * 2;
                        const radius = 200 + Math.random() * 80;
                        return {
                            x: 400 + Math.cos(angle) * radius,
                            y: 300 + Math.sin(angle) * radius * 0.6
                        };
                    },
                    (index, total) => {
                        return {
                            x: 120 + Math.random() * 560,
                            y: 100 + Math.random() * 400
                        };
                    },
                    (index, total) => {
                        const isTopRow = index < total / 2;
                        const posInRow = index % Math.ceil(total / 2);
                        const rowSize = Math.ceil(total / 2);
                        const spacing = Math.max(120, 600 / rowSize);
                        return {
                            x: 100 + (posInRow * spacing) + Math.random() * 40 - 20,
                            y: isTopRow ? 120 + Math.random() * 40 : 380 + Math.random() * 40
                        };
                    }
                ];

                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                const generatedPositions = [];

                for (let i = 0; i < serverCount; i++) {
                    let pos;
                    let attempts = 0;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 50) {
                        pos = pattern(i, serverCount);
                        pos.x = Math.max(100, Math.min(700, pos.x));
                        pos.y = Math.max(80, Math.min(520, pos.y));
                        
                        validPosition = true;
                        for (let existingPos of generatedPositions) {
                            if (new Vector2(pos.x, pos.y).distance(existingPos) < 120) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    if (!validPosition) {
                        const gridX = i % 4;
                        const gridY = Math.floor(i / 4);
                        pos = { x: 150 + gridX * 150, y: 150 + gridY * 120 };
                    }
                    
                    generatedPositions.push(new Vector2(pos.x, pos.y));
                    let subnet = null;
                    if (this.level >= 3) {
                        subnet = this.subnets[Math.floor(Math.random() * this.subnets.length)];
                    }
                    
                    const ip = this.generateIP(subnet);
                    const server = new ServerNode(pos.x, pos.y, ip, subnet);
                    
                    if (isEarlyLevel && (pos.x < 200 || pos.x > 600) && (pos.y < 200 || pos.y > 400)) {
                        server.safeZone = true;
                    }
                    this.servers.push(server);
                }

                const nonSafeServers = this.servers.filter(s => !s.safeZone);
                const targetServer = nonSafeServers[Math.floor(Math.random() * nonSafeServers.length)];
                targetServer.isTarget = true;
                this.targetIP = targetServer.ip;
                
                if (this.level >= 5) {
                    const allPorts = [80, 22, 25, 21, 53, 443, 8080];
                    this.targetPort = allPorts[Math.floor(Math.random() * allPorts.length)];
                    targetServer.targetPort = this.targetPort;
                    
                    this.servers.forEach(server => {
                        if (server.safeZone) return;
                        
                        const numPorts = 1 + Math.floor(Math.random() * 3);
                        const serverPorts = [];
                        
                        for (let i = 0; i < numPorts; i++) {
                            let port;
                            do {
                                port = allPorts[Math.floor(Math.random() * allPorts.length)];
                            } while (serverPorts.includes(port));
                            serverPorts.push(port);
                        }
                        
                        if (server.isTarget && !serverPorts.includes(this.targetPort)) {
                            serverPorts[0] = this.targetPort;
                        }
                        
                        server.availablePorts = serverPorts.sort((a, b) => a - b);
                    });
                    
                    document.getElementById('targetPort').textContent = `PORT: ${this.targetPort}`;
                    document.getElementById('targetPort').style.display = 'block';
                } else {
                    this.targetPort = null;
                    this.servers.forEach(server => { server.availablePorts = []; });
                    document.getElementById('targetPort').style.display = 'none';
                }
                
                document.getElementById('targetIP').textContent = this.targetIP;

                if (this.level >= 7) {
                    const routerCount = 2 + Math.floor(this.level / 8);
                    const routerPositions = [];
                    
                    for (let i = 0; i < routerCount; i++) {
                        let x, y, validPosition = false;
                        let attempts = 0;
                        
                        while (!validPosition && attempts < 50) {
                            x = Math.random() * (800 - 200) + 100;
                            y = Math.random() * (600 - 200) + 100;
                            
                            validPosition = true;
                            for (let server of this.servers) {
                                if (server.position.distance(new Vector2(x, y)) < 60) { validPosition = false; break; }
                            }
                            for (let pos of routerPositions) {
                                if (pos.distance(new Vector2(x, y)) < 80) { validPosition = false; break; }
                            }
                            attempts++;
                        }
                        if (validPosition) routerPositions.push(new Vector2(x, y));
                    }
                    
                    for (let i = 0; i < routerPositions.length; i += 2) {
                        const router1 = new Router(routerPositions[i].x, routerPositions[i].y);
                        let router2 = null;
                        
                        if (i + 1 < routerPositions.length) {
                            router2 = new Router(routerPositions[i + 1].x, routerPositions[i + 1].y);
                            router1.linkedRouter = router2;
                            router2.linkedRouter = router1;
                        }
                        
                        this.routers.push(router1);
                        if (router2) this.routers.push(router2);
                    }
                }

                const resourceCount = isEarlyLevel ? 4 : (3 + Math.floor(this.level / 3));
                const resourceTypes = ['packet', 'bandwidth', 'cache', 'ping'];
                
                for (let i = 0; i < resourceCount; i++) {
                    let x, y, validPosition = false;
                    let attempts = 0;
                    
                    while (!validPosition && attempts < 50) {
                        x = Math.random() * (800 - 100) + 50;
                        y = Math.random() * (600 - 100) + 50;
                        
                        validPosition = true;
                        for (let server of this.servers) {
                            if (server.position.distance(new Vector2(x, y)) < 50) { validPosition = false; break; }
                        }
                        for (let router of this.routers) {
                            if (router.position.distance(new Vector2(x, y)) < 40) { validPosition = false; break; }
                        }
                        attempts++;
                    }
                    
                    if (validPosition) {
                        const type = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                        this.networkResources.push(new NetworkResource(x, y, type));
                    }
                }

                let firewallCount;
                if (this.level === 1) { firewallCount = 0; } 
                else if (this.level <= 3) { firewallCount = 1; } 
                else { firewallCount = Math.min(1 + Math.floor(this.level / 1.5), 7); }
                
                const plannedSpawnPosition = this.findSafeSpawnPosition();
                
                for (let i = 0; i < firewallCount; i++) {
                    let x, y, validPosition = false;
                    let attempts = 0;
                    
                    while (!validPosition && attempts < 50) {
                        x = Math.random() * (800 - 120) + 60;
                        y = Math.random() * (600 - 120) + 60;
                        
                        validPosition = true;
                        if (new Vector2(x, y).distance(plannedSpawnPosition) < (isEarlyLevel ? 140 : 110)) {
                            validPosition = false;
                        }
                        
                        for (let server of this.servers) {
                            if (server.safeZone && server.position.distance(new Vector2(x, y)) < 60) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    if (validPosition) {
                        const firewall = new Firewall(x, y);
                        firewall.level = this.level;
                        this.firewalls.push(firewall);
                    }
                }

                this.updateSubnetLegend();
                const spawnPosition = this.findSafeSpawnPosition();
                this.player.position = spawnPosition;
                this.player.triggerSpawn();
                this.networkTipShown = false;

                if ((this.level === 3 || this.level === 5 || this.level === 7 || this.level === 10) && !this.networkTipShown) {
                    setTimeout(() => {
                        if (this.gameRunning && !this.player.isSpawning()) {
                            const tipIndex = Math.floor((this.level - 3) / 2);
                            this.showNetworkTip(tipIndex);
                        }
                    }, 1800);
                }
            }

            update() {
                if (this.gameState !== 'PLAYING' || !this.gameRunning) {
                    return;
                }

                this.player.update(this.input);

                if (this.player.isSpawning()) {
                    this.servers.forEach(server => server.update());
                    this.networkResources.forEach(resource => resource.update());
                    this.routers.forEach(router => router.update());

                    const safeZoneServers = this.servers.filter(s => s.safeZone);
                    this.firewalls.forEach(firewall => firewall.update(safeZoneServers, this.level));

                    this.particles = this.particles.filter(particle => {
                        particle.update();
                        return !particle.isDead();
                    });

                    if (this.screenShake > 0) this.screenShake--;
                    return;
                }

                this.servers.forEach(server => server.update());
                this.networkResources.forEach(resource => resource.update());
                this.routers.forEach(router => router.update());

                const safeZoneServers = this.servers.filter(s => s.safeZone);
                this.firewalls.forEach(firewall => firewall.update(safeZoneServers, this.level));

                this.particles = this.particles.filter(particle => {
                    particle.update();
                    return !particle.isDead();
                });

                if (this.screenShake > 0) this.screenShake--;

                this.networkResources = this.networkResources.filter(resource => {
                    if (resource.checkCollision(this.player)) {
                        let scoreGain = 25;
                        let message = resource.name;
                        
                        switch(resource.type) {
                            case 'packet':
                                this.ttl = Math.min(200, this.ttl + resource.value);
                                scoreGain = 30;
                                break;
                            case 'bandwidth':
                                this.player.bandwidthBoost = 300;
                                scoreGain = 40;
                                break;
                            case 'cache':
                                this.ttl = Math.min(200, this.ttl + resource.value);
                                scoreGain = 60;
                                break;
                            case 'ping':
                                this.ttl = Math.min(200, this.ttl + resource.value);
                                scoreGain = 15;
                                break;
                        }
                        
                        this.score += scoreGain;
                        this.addParticles(resource.position.x, resource.position.y, resource.color, 10);
                        this.showCelebration(message, resource.position.x, resource.position.y);
                        return false;
                    }
                    return true;
                });

                this.routers.forEach(router => {
                    if (router.checkCollision(this.player) && router.linkedRouter) {
                        this.player.position = new Vector2(router.linkedRouter.position.x, router.linkedRouter.position.y);
                        router.activate();
                        router.linkedRouter.activate();
                        this.addParticles(router.position.x, router.position.y, '#00aa00', 15);
                        this.addParticles(router.linkedRouter.position.x, router.linkedRouter.position.y, '#00aa00', 15);
                        this.showCelebration('ROUTED!', router.position.x, router.position.y);
                        this.addScreenShake(5);
                    }
                });

                this.servers.forEach(server => {
                    if (server.checkCollision(this.player)) {
                        if (server.isTarget) {
                            if (this.targetPort && !server.hasPort(this.targetPort)) {
                                this.addParticles(server.position.x, server.position.y, '#ffaa00', 12);
                                this.showCelebration('WRONG PORT!', server.position.x, server.position.y - 20);
                                this.addScreenShake(4);
                                this.ttl -= 8;
                                
                                const pushDirection = this.player.position.add(server.position.multiply(-1)).normalize();
                                this.player.position = this.player.position.add(pushDirection.multiply(25));
                                return;
                            }
                        } else {
                            this.addParticles(server.position.x, server.position.y, '#ff6666', 12);
                            this.showCelebration('WRONG IP!', server.position.x, server.position.y - 20);
                            this.addScreenShake(3);
                            this.ttl -= 3;
                            
                            const pushDirection = this.player.position.add(server.position.multiply(-1)).normalize();
                            this.player.position = this.player.position.add(pushDirection.multiply(25));
                        }
                    }
                });
                const targetServer = this.servers.find(s => s.isTarget);
                if (targetServer && targetServer.checkCollision(this.player) && (!this.targetPort || targetServer.hasPort(this.targetPort))) {
                    this.combo++;
                    this.bestCombo = Math.max(this.bestCombo, this.combo);
                    
                    const baseScore = Math.floor(this.ttl * 10);
                    const comboBonus = this.combo * 150;
                    const levelBonus = this.level * 50;
                    const totalScore = baseScore + comboBonus + levelBonus;
                    
                    this.score += totalScore;
                    this.level++;
                    this.highestLevel = Math.max(this.highestLevel, this.level);
                    this.ttl = Math.min(200, this.ttl + 20);
                    
                    this.addParticles(targetServer.position.x, targetServer.position.y, '#00ff00', 25);
                    this.addScreenShake(10);
                    this.showCelebration(`PACKET DELIVERED! +${totalScore}`, targetServer.position.x, targetServer.position.y - 30);
                    
                    this.generateLevel();
                }

                for (let firewall of this.firewalls) {
                    if (firewall.checkCollision(this.player)) {
                        this.addParticles(this.player.position.x, this.player.position.y, '#ff3333', 20);
                        this.addScreenShake(15);
                        this.combo = 0;
                        this.gameOverReason = 'firewall';
                        this.gameOver();
                        return;
                    }
                }

                const ttlDecay = this.level <= 3 ? 0.10 : 0.14;
                this.ttl -= ttlDecay;
                if (this.ttl <= 0) {
                    this.gameOverReason = 'ttl';
                    this.gameOver();
                    return;
                }

                document.getElementById('score').textContent = `SCORE: ${Math.floor(this.score)}`;
                document.getElementById('level').textContent = `LEVEL: ${this.level}`;
                document.getElementById('ttl').textContent = `TTL: ${Math.floor(this.ttl)}`;
                document.getElementById('bandwidth').textContent = `BANDWIDTH: ${this.player.getBandwidthPercent()}%`;
                document.getElementById('combo').textContent = this.combo > 0 ? `COMBO: ${this.combo}x` : '';
                
                const dashPercent = this.player.getDashCooldownPercent();
                document.getElementById('dashBar').style.width = (dashPercent * 100) + '%';
            }

            render() {
                this.ctx.fillStyle = 'rgba(0, 0, 17, 0.12)';
                this.ctx.fillRect(0, 0, 800, 600);

                if (this.gameState !== 'PLAYING') {
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
                    this.ctx.lineWidth = 1;
                    for (let x = 0; x < 800; x += 40) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, 600);
                        this.ctx.stroke();
                    }
                    for (let y = 0; y < 600; y += 40) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(800, y);
                        this.ctx.stroke();
                    }
                    return;
                }

                let shakeX = 0, shakeY = 0;
                if (this.screenShake > 0) {
                    shakeX = (Math.random() - 0.5) * this.screenShake;
                    shakeY = (Math.random() - 0.5) * this.screenShake;
                }

                this.ctx.save();
                this.ctx.translate(shakeX, shakeY);

                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x < 800; x += 40) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, 600);
                    this.ctx.stroke();
                }
                for (let y = 0; y < 600; y += 40) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(800, y);
                    this.ctx.stroke();
                }

                this.servers.forEach(server => server.render(this.ctx));
                this.networkResources.forEach(resource => resource.render(this.ctx));
                this.routers.forEach(router => router.render(this.ctx));
                this.firewalls.forEach(firewall => firewall.render(this.ctx));
                this.particles.forEach(particle => particle.render(this.ctx));
                this.player.render(this.ctx);

                this.ctx.restore();
            }

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }

            gameOver() {
                this.gameRunning = false;
                const reasonText = this.getGameOverReason(this.gameOverReason);
                document.getElementById('gameOverReason').textContent = reasonText;
                document.getElementById('finalScore').textContent = Math.floor(this.score);
                document.getElementById('bestCombo').textContent = this.bestCombo;
                document.getElementById('highestLevel').textContent = this.highestLevel;
                document.getElementById('gameOver').style.display = 'block';
                document.getElementById('restartButton').focus();
                this.updateBlurEffect();
            }

            // --- RESTART FIX ---
            // The "BACK TO MENU" button now correctly calls this function,
            // which simply directs to the main menu screen.
            restart() {
                this.showStartMenu();
            }
        }

        const game = new IPVengerGame();
    </script>
</body>
</html>
